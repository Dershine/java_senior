# java八股文学习过程

## 一、Redis

### 使用场景

* 缓存
  * 穿透、击穿、雪崩
  * 双写一致、持久化
  * 数据过期策略、淘汰策略
* 分布式锁
  * setnx redisson
* 计数器
* 保存token
* 消息队列
* 延迟队列

### 缓存

#### 缓存穿透

* 定义
  * 查询一个不存在的数据，mysql查询不到数据也不会写入缓存，就会导致每次请求都查数据库

* 解决方案一
  * 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存
  * 优点 ***简单***
  * 缺点 ***消耗内存，可能会发生不一致的问题***

* 解决方案二
  * 布隆过滤器
  * 位图：相当于以 ***位(bit)*** 为单位的数字，数组中每个单元只能储存二进制数0或1
  * 作用： 布隆过滤器可以用于检索一个元素是否在一个集合中
  * 优点 ***内存占用小勺，没有多余key***
  * 缺点 ***实现复杂，存在误判***
* 原理
![布隆过滤器](image/Snipaste_2023-10-09_17-01-27.png)

* 误判
  * 数组越大，误判越小，内存消耗越高
![布隆过滤器](image/Snipaste_2023-10-09_17-21-13.png)


#### 缓存击穿

* 定义
  * 在某个key正好过期的时候，有大量对这个key的并发请求过来，这些并发请求可能会瞬间把DB压垮

* 解决方案一
  * 互斥锁
  * 优点 ***强一致性***
  * 缺点 ***性能差***

* 原理
![互斥锁](image/Snipaste_2023-10-09_17-33-11.png)


* 解决方案二
  * 逻辑过期
  * 在数据的字段中保存过期时间
  * 优点 ***高可用，性能优***
  * 缺点 ***不能保证数据绝对一致***
![逻辑过期](image/Snipaste_2023-10-09_17-38-46.png)


#### 缓存雪崩

* 定义
  * 同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力

* 解决方案一
  * 给不同的key的TTL添加随机值

* 解决方案二
  * 利用Redis集群提高服务的可用性 ***哨兵模式 集群模式***

* 解决方案三
  * 给缓存业务添加降级限流策略 ***保底策略，适用于穿透、击穿、雪崩***
  * ngxin 或 spring cloud gateway

* 解决方案四
  * 给业务添加多级缓存
  * Guava 或 Caffeine


#### 双写一致性

* 定义
  * 当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致
* 读操作
  * 缓存命中，直接返回；缓存未命中，查询数据库，写入缓存，设定过期时间
* 写操作
  * 延迟双删

* 先删除缓存，再操作数据库
  * 如果有线程在以上两个操作之间读取数据，则会将数据库的更新之前的脏数据写入缓存中，造成双写不一致
![双写不一致](image/Snipaste_2023-10-09_18-06-41.png)

* 先操作数据库，再删除缓存
  * 如果有线程在删除缓存之前读到了缓存中的数据，并且在删除缓存后又将脏数据存入了缓存，就会造成双写不一致
![双写不一致](image/Snipaste_2023-10-09_18-28-17.png)

* 为什么要延时？
  * 给从数据库同步主数据库的数据的时间

* 绝对保证数据的一致性
  * 加分布式锁

* 读写锁
  * 共享锁：可以读，不可以写
  * 排他锁：不可以读写

* 异步通知保证数据的最终一致性
![双写一致](image/Snipaste_2023-10-11_11-54-06.png)
![双写一致](image/Snipaste_2023-10-11_11-56-57.png)


#### 持久化

* RDB
* 全称为Redis Database Backup file(Redis数据备份文件)，也叫Redis数据快照
  * 在redis控制台输入save，由redis主进程来执行RDB，会阻塞所有命令
  * 在控制台输入bgsave，开启子进程执行RDB，避免主进程受到影响
* 原理
  * 子进程从主进程复制页表，获得虚拟地址对物理地址的映射，写新的RDB文件，替换旧的RDB文件
  * 如果在子进程写新的RDB文件的过程中，主进程又执行RDB操作，则有可能产生脏数据
    * 解决方法：在子进程对物理内存操作时，给对应的数据添加read-only锁，如果主进程有写操作，则从read-only区域拷贝一份数据副本B来操作，如果只是读，则不用拷贝
![持久化](image/Snipaste_2023-10-11_12-16-26.png)


* AOF
  * 全称为Append Only File(追加文件)，Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件
  * AOF默认关闭，需要修改redis.conf配置文件来开启AOF
![AOF](image/Snipaste_2023-10-11_11-56-57.png)


### 2、其他面试题

* 集群
  * 主从
  * 哨兵
  * 集群
* 事务
* redis为什么这么快


## MySQL

### 如何定位慢查询

* 使用工具
  * Arthas
  * Prometheus
  * Skywalking

* 开启MySQL慢查询日志


### SQL执行慢，如何分析

* 使用MySQL自带分析工具EXPLAIN分析


### 索引

* 什么是索引
  * 帮助MySQL高效获取数据的数据结构（有序）

* MySQL的InnoDB引擎采用B+树的数据结构来储存索引
  * 只有叶子节点储存数据，读写代价低
  * 叶子节点是双向链表，便于扫描

* 什么是聚簇索引，什么是非聚簇索引
  * 聚簇索引（聚集索引），索引包含整行的数据
  * 非聚簇索引（二级索引），由数据找到主键的索引

* 什么是回表查询
  * 先用二级索引由数据找到主键，再用聚簇索引由主键找到整行数据

* 什么是覆盖索引
  * 查询一次直接获得所有需要的数据，不需要回表查询的索引，就叫覆盖索引，即查询一次性命中

* MYSQL超大分页怎么处理
  * 覆盖索引+子查询

* 索引创建的原则有哪些
  * ***数据量较大，且查询频繁的表***
  * ***常作为查询条件、排序、分组的字段***
  * 字段内容区分度高
  * 内容较长，使用前缀索引
  * ***尽量使用联合索引***
  * ***要控制索引的数量***
  * 如果索引不能储存NULL值，请在创建表时使用NOT NULL约束它

  * 什么情况下索引会失效？
    * 违反最左前缀法则
    * 如果查询中有一个范围查询，那么范围查询右边的列，不能使用索引
    * 不要在索引列上进行运算操作，索引将失效
    * 字符串不加单引号，索引失效。（类型转换）
    * 以%开头的模糊查询Like，索引失效（注意仅在开头会失效，在结尾不会）

* 谈谈你对sql的优化经验

  * 表的设计优化
    * 设置合适的数值，根据实际情况选择
    * 设置合适的字符串类型，char定长效率高，varchar可变长度，效率偏低

  * SQL语句优化
    * select 语句务必指名字段，避免直接使用 select *
    * SQL语句要避免索引失效的写法
    * 尽量用 union all 替代 union ，后者比前者多一次过滤操作
    * 避免在 where 子句中对字段进行表达式操作
    * join 优化，能用innerjoin就不要使用left join right join，如必须要使用，一定要以小表为驱动（小表在外层），内连接会对两个表进行优化

  * 主从复制，读写分离

  * 分库分表


### 事务

* 事务的特性

  * 原子性
    * 事务是不可分割的最小操作单元，全部成功，或全部失败

  * 一致性
    * 事务完成后所有数据必须保持一致

  * 隔离性
    * 事务在不受外部并发操作影响的独立环境下运行

  * 持久性
    * 事务对数据的改变时永久的


* 并发事务问题

  * 问题
    * 脏读
    * 不可重复读
    * 幻读
  
  * 解决方案：隔离
    * 读未提交 Read Uncommitted
    * 读已提交 Read committed
    * 可重复读 Repeatable Read （默认）
    * 串行化 Serializable

* redo log 和 undo log

  * redo log
    * 记录的是数据页的物理变化，服务宕机时可用来同步数据

  * undo log
    * 记录的时逻辑日志，当事务回滚时，通过逆操作恢复原来的数据

  * redo log 保证事务的持久性，undo log 保证事务的原子性和一致性


### MVCC-多版本并发控制

* 定义
  * 维护一个数据的多个版本，使得读写操作没有冲突

* 隐藏字段
  * trx_id (事务id)，记录每一次操作的事务id，是自增的
  * roll_pointer (回滚指针)，指向上一个版本的事务记录的地址

* undo log
  * 回滚日志，储存老版本数据
  * 版本链：多个事务共同操作某一数据，记录不同数据修改数据的版本，通过roll_pointer指针形成一个链表

* readView
  * 根据readView的匹配规则和当前的一些事务id判断该访问哪个版本的数据
  * 不同隔离级别的快照读不一样，访问的版本不同
    * RC 每一次执行快照读时生成一个readView
    * RR 仅在第一次执行快照读时生成一个readView


### 主从同步原理

* MySQL主从复制的核心就是二进制日志binlog(DDL(数据定义语言)语句和DML(数据操纵语言)语句)
  * 主库在数据提交时，会把数据变更记录在二进制日志文件binlog中
  * 从库读取主库的二进制文件binlog，写入到从库的中继日志文件Relay log中
  * 从库重做中继日志文件中的事件，将改变它自己的数据