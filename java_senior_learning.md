# java八股文学习过程

## 一、Redis

### 使用场景

* 缓存
  * 穿透、击穿、雪崩
  * 双写一致、持久化
  * 数据过期策略、淘汰策略
* 分布式锁
  * setnx redisson
* 计数器
* 保存token
* 消息队列
* 延迟队列

### 缓存

#### 缓存穿透

* 定义
  * 查询一个不存在的数据，mysql查询不到数据也不会写入缓存，就会导致每次请求都查数据库

* 解决方案一
  * 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存
  * 优点 ***简单***
  * 缺点 ***消耗内存，可能会发生不一致的问题***

* 解决方案二
  * 布隆过滤器
  * 位图：相当于以 ***位(bit)*** 为单位的数字，数组中每个单元只能储存二进制数0或1
  * 作用： 布隆过滤器可以用于检索一个元素是否在一个集合中
  * 优点 ***内存占用小勺，没有多余key***
  * 缺点 ***实现复杂，存在误判***
* 原理
![布隆过滤器](image/Snipaste_2023-10-09_17-01-27.png)

* 误判
  * 数组越大，误判越小，内存消耗越高
![布隆过滤器](image/Snipaste_2023-10-09_17-21-13.png)


#### 缓存击穿

* 定义
  * 在某个key正好过期的时候，有大量对这个key的并发请求过来，这些并发请求可能会瞬间把DB压垮

* 解决方案一
  * 互斥锁
  * 优点 ***强一致性***
  * 缺点 ***性能差***

* 原理
![互斥锁](image/Snipaste_2023-10-09_17-33-11.png)


* 解决方案二
  * 逻辑过期
  * 在数据的字段中保存过期时间
  * 优点 ***高可用，性能优***
  * 缺点 ***不能保证数据绝对一致***
![逻辑过期](image/Snipaste_2023-10-09_17-38-46.png)


#### 缓存雪崩

* 定义
  * 同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力

* 解决方案一
  * 给不同的key的TTL添加随机值

* 解决方案二
  * 利用Redis集群提高服务的可用性 ***哨兵模式 集群模式***

* 解决方案三
  * 给缓存业务添加降级限流策略 ***保底策略，适用于穿透、击穿、雪崩***
  * ngxin 或 spring cloud gateway

* 解决方案四
  * 给业务添加多级缓存
  * Guava 或 Caffeine


#### 双写一致性

* 定义
  * 当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致
* 读操作
  * 缓存命中，直接返回；缓存未命中，查询数据库，写入缓存，设定过期时间
* 写操作
  * 延迟双删

* 先删除缓存，再操作数据库
  * 如果有线程在以上两个操作之间读取数据，则会将数据库的更新之前的脏数据写入缓存中，造成双写不一致
![双写不一致](image/Snipaste_2023-10-09_18-06-41.png)

* 先操作数据库，再删除缓存
  * 如果有线程在删除缓存之前读到了缓存中的数据，并且在删除缓存后又将脏数据存入了缓存，就会造成双写不一致
![双写不一致](image/Snipaste_2023-10-09_18-28-17.png)

* 为什么要延时？
  * 给从数据库同步主数据库的数据的时间

* 绝对保证数据的一致性
  * 加分布式锁

* 读写锁
  * 共享锁：可以读，不可以写
  * 排他锁：不可以读写

* 异步通知保证数据的最终一致性
![双写一致](image/Snipaste_2023-10-11_11-54-06.png)
![双写一致](image/Snipaste_2023-10-11_11-56-57.png)


#### 持久化

* RDB
* 全称为Redis Database Backup file(Redis数据备份文件)，也叫Redis数据快照
  * 在redis控制台输入save，由redis主进程来执行RDB，会阻塞所有命令
  * 在控制台输入bgsave，开启子进程执行RDB，避免主进程受到影响
* 原理
  * 子进程从主进程复制页表，获得虚拟地址对物理地址的映射，写新的RDB文件，替换旧的RDB文件
  * 如果在子进程写新的RDB文件的过程中，主进程又执行RDB操作，则有可能产生脏数据
    * 解决方法：在子进程对物理内存操作时，给对应的数据添加read-only锁，如果主进程有写操作，则从read-only区域拷贝一份数据副本B来操作，如果只是读，则不用拷贝
![持久化](image/Snipaste_2023-10-11_12-16-26.png)


* AOF
  * 全称为Append Only File(追加文件)，Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件
  * AOF默认关闭，需要修改redis.conf配置文件来开启AOF
![AOF](image/Snipaste_2023-10-11_11-56-57.png)


### 2、其他面试题

* 集群
  * 主从
  * 哨兵
  * 集群
* 事务
* redis为什么这么快


## MySQL

### 如何定位慢查询

#### 1、使用工具

* Arthas
* Prometheus
* Skywalking

#### 2、开启MySQL慢查询日志

### SQL执行慢，如何分析

* 使用MySQL自带分析工具EXPLAIN分析

### 索引

#### 1、什么是索引

* 帮助MySQL高效获取数据的数据结构（有序）

#### 2、MySQL的InnoDB引擎采用B+树的数据结构来储存索引

* 只有叶子节点储存数据，读写代价低
* 叶子节点是双向链表，便于扫描

#### 3、什么是聚簇索引，什么是非聚簇索引

* 聚簇索引（聚集索引），索引包含整行的数据
* 非聚簇索引（二级索引），由数据找到主键的索引

#### 4、什么是回表查询

* 先用二级索引由数据找到主键，再用聚簇索引由主键找到整行数据

#### 4、什么是覆盖索引

* 查询一次直接获得所有需要的数据，不需要回表查询的索引，就叫覆盖索引，即查询一次性命中

#### 5、MYSQL超大分页怎么处理

* 覆盖索引+子查询

#### 6、索引创建的原则有哪些

* ***数据量较大，且查询频繁的表***
* ***常作为查询条件、排序、分组的字段***
* 字段内容区分度高
* 内容较长，使用前缀索引
* ***尽量使用联合索引***
* ***要控制索引的数量***
* 如果索引不能储存NULL值，请在创建表时使用NOT NULL约束它