# java八股文学习过程

## 一、Redis

### 使用场景

* 缓存
  * 穿透、击穿、雪崩
  * 双写一致、持久化
  * 数据过期策略、淘汰策略
* 分布式锁
  * setnx redisson
* 计数器
* 保存token
* 消息队列
* 延迟队列

### 缓存

#### 缓存穿透

* 定义
  * 查询一个不存在的数据，mysql查询不到数据也不会写入缓存，就会导致每次请求都查数据库

* 解决方案一
  * 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存
  * 优点 ***简单***
  * 缺点 ***消耗内存，可能会发生不一致的问题***

* 解决方案二
  * 布隆过滤器
  * 位图：相当于以 ***位(bit)*** 为单位的数字，数组中每个单元只能储存二进制数0或1
  * 作用： 布隆过滤器可以用于检索一个元素是否在一个集合中
  * 优点 ***内存占用小勺，没有多余key***
  * 缺点 ***实现复杂，存在误判***
* 原理
![布隆过滤器](image/Snipaste_2023-10-09_17-01-27.png)

* 误判
  * 数组越大，误判越小，内存消耗越高
![布隆过滤器](image/Snipaste_2023-10-09_17-21-13.png)


#### 缓存击穿

* 定义
  * 在某个key正好过期的时候，有大量对这个key的并发请求过来，这些并发请求可能会瞬间把DB压垮

* 解决方案一
  * 互斥锁
  * 优点 ***强一致性***
  * 缺点 ***性能差***

* 原理
![互斥锁](image/Snipaste_2023-10-09_17-33-11.png)


* 解决方案二
  * 逻辑过期
  * 在数据的字段中保存过期时间
  * 优点 ***高可用，性能优***
  * 缺点 ***不能保证数据绝对一致***
![逻辑过期](image/Snipaste_2023-10-09_17-38-46.png)


#### 缓存雪崩

* 定义
  * 同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力

* 解决方案一
  * 给不同的key的TTL添加随机值

* 解决方案二
  * 利用Redis集群提高服务的可用性 ***哨兵模式 集群模式***

* 解决方案三
  * 给缓存业务添加降级限流策略 ***保底策略，适用于穿透、击穿、雪崩***
  * ngxin 或 spring cloud gateway

* 解决方案四
  * 给业务添加多级缓存
  * Guava 或 Caffeine


#### 双写一致性

* 定义
  * 当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致
* 读操作
  * 缓存命中，直接返回；缓存未命中，查询数据库，写入缓存，设定过期时间
* 写操作
  * 延迟双删

* 先删除缓存，再操作数据库
  * 如果有线程在以上两个操作之间读取数据，则会将数据库的更新之前的脏数据写入缓存中，造成双写不一致
![双写不一致](image/Snipaste_2023-10-09_18-06-41.png)

* 先操作数据库，再删除缓存
  * 如果有线程在删除缓存之前读到了缓存中的数据，并且在删除缓存后又将脏数据存入了缓存，就会造成双写不一致
![双写不一致](image/Snipaste_2023-10-09_18-28-17.png)


### 2、其他面试题

* 集群
  * 主从
  * 哨兵
  * 集群
* 事务
* redis为什么这么快